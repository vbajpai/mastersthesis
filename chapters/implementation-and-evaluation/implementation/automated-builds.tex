A considerate amount of attention was paid to make sure the execution engine
utilize only standard ANSI libraries to allow it to seamlessly build
\marginpar{feature test macros} across Unix platforms. Since the engine
depends on the \texttt{flow-tools} library that uses BSD extensions, it proved
useful to include the \texttt{GNU\_SOURCE} feature test macro.
\texttt{GNU\_SOURCE} allows to request and let the compiler enable a larger
class of features.

CMake was used to ensure a compiler and platform independent build process
\footnote{detailed engine installation instructions are available in the
appendix.}.  Since the execution engine requires some headers/sources that are
auto-generated by a python script, a custom command was added to run the
script on each compilation to add the generated files \marginpar{cmake
custom commands} in \texttt{.build/} as shown in listing
\ref{lst:fv2-cmake-custom-commands}. These files are automatically included
during the compilation and linked to the final binary.  CMake also
runs the build query scripts defined in \texttt{scripts/queries/} to generate
some example \texttt{JSON} queries and moves them to the \texttt{examples/}
folder ready to be used by the binary as shown in listing
\ref{lst:fv2-cmake-custom-commands}.

\lstset{caption=F$(v2)$: CMake Custom Commands,
				tabsize=2, language=bash, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-cmake-custom-commands,
        aboveskip=20pt, captionpos=b, upquote=true}
\begin{lstlisting}
# custom command to prepare auto-generated sources
add_custom_command (
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/auto-assign.h
         ${CMAKE_CURRENT_BINARY_DIR}/auto-assign.c
         ${CMAKE_CURRENT_BINARY_DIR}/auto-comps.h
         ${CMAKE_CURRENT_BINARY_DIR}/auto-comps.c
  COMMAND python ${CMAKE_SOURCE_DIR}/scripts/generate-functions.py
  COMMENT "Generating: auto-comps{h,c} and auto-assign.{h,c}"
)

# custom command to generate examples
file(GLOB pyFILES ${CMAKE_SOURCE_DIR}/scripts/queries/*.py)
foreach(pyFILE ${pyFILES})
  set(query "${pyFILE}_query")
  add_custom_command (
    OUTPUT ${query}
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/examples/
    COMMAND python ${pyFILE}
    COMMENT "Generating: JSON example query using ${pyFILE}"
  )
  list(APPEND queryFILES ${query})
endforeach(pyFILE)
\end{lstlisting}

CMake build process requires one to invoke quite a number of bash commands as
shown in listing \ref{lst:fv2-automate-cmake-invocations}. In essence, a user
does not need to know the CMake \emph{way} to working around the build to use
the execution \marginpar{makefile to automate cmake} engine. As such a
\texttt{Makefile} is included that can make CMake calls to automate this
operation. Additional targets to clean and generate \texttt{doxygen}
documentation. The generated documentation goes in \texttt{doc/} and is
subsequently deleted by a cleanup.

\lstset{caption=F$(v2)$: Automating CMake Invocations,
				tabsize=2, language=bash, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-automate-cmake-invocations,
        aboveskip=20pt, captionpos=b, upquote=true}
\begin{lstlisting}
[engine] $ mkdir .build
[engine] $ cd .build
[.build] $ cmake ..
[.build] $ make
[.build] $ cd ..
[engine] $ rm -r .build

[engine] $ cat Makefile

make: build/Makefile
    (cd .build; make)
build/Makefile: build
    (cd .build; cmake -D CMAKE_PREFIX_PATH=$(CMAKE_PREFIX_PATH) ..)
build:
    mkdir -p .build
doc: Doxyfile
    (mkdir -p doc; doxygen Doxyfile)
clean:
    rm -f -r .build/ bin/ doc/
    rm -f -r examples/*.json
\end{lstlisting}

The Makefile can also take \texttt{CMAKE\_PREFIX\_PATH} as an argument and
pass it on to CMake. \texttt{CMAKE\_PREFIX\_PATH} is used to supply arbitrary
\marginpar{cmake prefix path} location of external libraries and include
\texttt{PATH}. This can be useful since the \texttt{flow-tools} installation
from source dispatches the library and headers in
\texttt{/usr/local/flow-tools}.

\lstset{caption=F$(v2)$: CMake Prefix Paths,
				tabsize=2, language=bash, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-cmake-prefix-paths,
        aboveskip=20pt, captionpos=b, upquote=true}
\begin{lstlisting}
[engine] $ make CMAKE_PREFIX_PATH=/usr/local/flow-tools
\end{lstlisting}





There has never been a clean seamless way to install python flowy.  Since the
parser in the flowy implementation is eventually going to converge with the
new execution engine, it is essential to provide an easy way to install and
manage the parser. The software tool used in the python ecosystem to manage
packages is \texttt{pip}. It uses a \emph{flat} \marginpar{packaging the
parser} \texttt{requirements.txt} file to install all the package dependencies
in one go. However, it requires that all the (to be) installed dependencies do
not import external packages in their \texttt{egg} files. This turned to be
the case for \texttt{numexpr} which is required by the parser, thereby
resulting in failed installation.  To circumvent the issue, a custom
\texttt{Makefile} was created that virtually adds a preprocessing pass to
install \texttt{numexpr} dependencies before going forward with installation
from \texttt{requirements.txt} as shown in listing
\ref{lst:fv2-automate-parser-installation}.

\lstset{caption=F$(v2)$: Automating Parser Installation,
				tabsize=2, language=bash, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-automate-parser-installation,
        aboveskip=20pt, captionpos=b, upquote=true}
\begin{lstlisting}
make: numexpr
        (pip install -r requirements.txt)
numexpr: numpy
        (pip install numexpr==2.0.1)
numpy: cython
        (pip install numpy==1.6.1)
cython:
        (pip install Cython==0.15.1)
clean:
        rm -f -r build/
        rm -f -r src/*.pyc
        rm -f -r flowy-run/
        rm -f -r parsetab.py parser.out
        rm -f -r examples/output.h5
\end{lstlisting}
