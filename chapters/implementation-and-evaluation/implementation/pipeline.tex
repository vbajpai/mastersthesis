The groupfilter is used to filter the groups produced by the grouper based on
some absolute rules defined in a \ac{DNF} expression. The \texttt{struct} rule
holds information about the flow record offset, the value being compared to
and the operator which maps to a unique \texttt{enum} value.  This enum
\marginpar{group filter implementation} value is later used to map the
operation to a specific group-filter function using a \texttt{switch} case as
shown in listing \ref{lst:fv2-gfilter-implementation}.  The group-filter
functions are auto-generated using a python script
\texttt{scripts/generate-functions.py}.

\lstset{caption=F$(v2)$: Group Filter Implementation,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-gfilter-implementation,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
/* assign group filter func for each term */
for (int k = 0; k < num_groupfilter_clauses; k++) {

  struct groupfilter_clause* gclause = groupfilter_clauseset[k];

  for (int j = 0; j < gclause->num_terms; j++) {

    /* assign a uintX_t specific function depending on grule->op */
    struct groupfilter_term* term = gclause->termset[j];
    assign_groupfilter_func(term);
  }
}

void
assign_groupfilter_func(struct groupfilter_term* const term) {

  switch (
          term->op->op |
          term->op->field_type
         ) {

    case RULE_EQ | RULE_S1_8:
      term->func = gfilter_eq_uint8_t;
      break;
    ...
  }
}
\end{lstlisting}

The merger is used to relate the groups from different branches according to a
criterean. Similar \marginpar{merger implementation} to the group filter, a
unique \texttt{enum} value is used to map the operator to a specific specific
merger function using a \texttt{switch} case as shown in listing
\ref{lst:fv2-merger-implementation}.  The merger functions are again
auto-generated using \texttt{scipts/generate-functions.py}.

\lstset{caption=F$(v2)$: Merger Implementation,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-merger-implementation,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
/* assign merger func for each term */
for (int k = 0; k < num_merger_clauses; k++) {

  struct merger_clause* mclause = merger_clauseset[k];

  for (int j = 0; j < mclause->num_terms; j++) {

    /* assign a uintX_t specific function depending on grule->op */
    struct merger_term* term = mclause->termset[j];
    assign_merger_func(term);
  }
}

void
assign_merger_func(struct merger_term* const term) {

  switch (
           term->op->op |
           term->op->field1_type |
           term->op->field2_type
         ) {

    case RULE_EQ | RULE_S1_8 | RULE_S2_8:
      term->func = merger_eq_uint8_t_uint8_t;
      break;
      ...
  }
}
\end{lstlisting}

Given the group tuples, the ungrouper returns a streamset of flow records
\footnote{A \texttt{stream} is a collection of flow-records of a group
unfolded by the ungrouper}\footnote{A \texttt{streamset} is collection of all
the streams unfolded by the ungrouper} . \marginpar{ungrouper implementation}
The matched group tuples are generated by the merger. The ungrouper returns as
many streams as there are number of matched group tuples.  An example output
is shown in listing \ref{lst:fv2-ungrouper-echo}.

\lstset{caption=F$(v2)$: Ungrouper Result Echo,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-ungrouper-echo,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
$ bin/engine tracefile queryfile
No. of Streams: 2
No. of Records in Stream (1): 24

... Sif   SrcIPaddress    SrcP  DIf   DstIPaddress    DstP  ...

... 0     192.168.0.135   56225 0     216.46.94.66    80    ...
... 0     216.46.94.66    80    0     192.168.0.135   56228 ...
\end{lstlisting}



There are dedicated comparator functions for each \texttt{uintX\_t} type of
the field offset. Up until now, the choice for the function was made using a
single function, \texttt{assign\_fptr(\ldots)}, which was called before the
start of the pipeline to ensure all function pointers point to the right
functions for each stage as shown in listing \ref{lst:fv1-assign-fptr}.


\lstset{caption=F$(v1)$: Early Comparator Assignments,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv1-assign-fptr,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
assign_fptr(struct flowquery *fquery) {
  for (int i = 0; i < fquery->num_branches; i++) {
    /* for loop for the filter */
    for (int j = 0; j < branch->num_filter_rules; j++) {...}
    /* for loop for the grouper */
    for (int j = 0; j < branch->num_grouper_rules; j++) {...}
    /* for loop for the group-aggregation */
    for (int j = 0; j < branch->num_aggr_rules; j++) {...}
    /* for loop for the group-filter */
    for (int j = 0; j < branch->num_gfilter_rules; j++) {...}
  }
}
\end{lstlisting}

This function is computationally expensive, since it falls through a
\emph{huge} \texttt{switch} statement to determine the function of right type.
It is not guaranteed that given the type of the query and trace, the program
will eventually go through each stage of the pipeline. It is also possible
\marginpar{lazy comparator assignments} that the program exits before, because
there is nothing more for the next stage to compute. The function pointers
should therefore be set as late as possible as shown in listing
\ref{lst:fv2-lazy-rule-assign}. Each of these functions are called from their
respective stages just before the comparison.  As a result, we save the
computation time wasted in setting the function pointer for stage $X$ if $X$
is never executed.

\lstset{caption=F$(v2)$: Lazy Comparator Assignments,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-lazy-rule-assign,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
void assign_filter_func(struct filter_term* const fterm);
void assign_grouper_func(struct grouper_term* const gterm);
void assign_aggr_func(struct aggr_term* const aterm);
void assign_groupfilter_func(struct groupfilter_term* const term);
void assign_merger_func(struct merger_term* const term);
\end{lstlisting}




The public interface function \texttt{grouper(\ldots)} call was plagued with
hardcoded \texttt{uint32\_t} type assumptions on the field offset. These field
offsets \marginpar{flexible grouper with no type assumptions} are used to
make grouper rule comparisons. The function now internally calls
\texttt{get\_gtype(\ldots)} to fall through a switch case to determine the
type of the field offset at runtime as shown in listing
\ref{lst:fv2-flexible-grouper}.

\lstset{caption=F$(v2)$: Flexible Grouper,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-flexible-grouper,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
struct grouper_type* get_gtype(uint64_t op) {
  switch (op) {
    case RULE_S2_8:
      gtype->qsort_comp = comp_uint8_t;
      gtype->bsearch = bsearch_uint8_t;
      gtype->alloc_uniqresult = alloc_uniqresult_uint8_t;
      gtype->get_uniq_record = get_uniq_record_uint8_t;
      gtype->dealloc_uniqresult = dealloc_uniqresult_uint8_t;
      break;
    case RULE_S2_16: ...
    case RULE_S2_32: ...
    case RULE_S2_64: ...
  }
  return gtype;
}
\end{lstlisting}



The group aggregation functions were hardcoded in \texttt{group\_aggr}
struct.  The functions are now replaced with rules that map to a specific
aggregation function. \marginpar{flexible group aggregations} The mapping of
the rule to the function is done using a \texttt{switch} case as shown in
listing \ref{lst:fv2-flexible-aggr}. The aggregation functions are
auto-generated using \texttt{scripts/generate-functions.py}.

\lstset{caption=F$(v2)$: Flexible Group Aggregations,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-flexible-aggr,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
/* assign a aggr func for each aggr clause term */
if (groupaggregations_enabled) {
  for (int j = 0; j < num_aggr_clause_terms; j++){

    struct aggr_term* term = aggr_clause_termset[j];
    assign_aggr_func(term);
  }
}

void
assign_aggr_func(struct aggr_term* const aterm) {

  switch (
          aterm->op->op |
          aterm->op->field_type
         ) {
    case RULE_STATIC | RULE_S1_8:
      aterm->func = aggr_static_uint8_t;
      break;
    ...
  }
}
\end{lstlisting}

The aggregation function also needs to know the type of the offsets used
previously in the filter and grouper rules to be able to fill in common fields
in its cooked netflow $v5$ group aggregation record. As a result
\marginpar{flexible group aggregation redundancy checks} a
\texttt{get\_aggr\_fptr(\ldots)} function was defined that accepts those
previous rules to fall through a switch to return a function pointer to an
aggregation function of the correct type as shown in listing
\ref{lst:fv2-getaggrfptr}. This aggregation function is then later used to
fill in the common fields. A similar call is made for the grouper rules as
well.

\lstset{caption=F$(v2)$: Flexible Group Aggregation Redundancy Checks,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-getaggrfptr,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
struct aggr*
(*get_aggr_fptr(
                 bool ifgrouper,
                 uint64_t op
               )) (
                    char** records,
                    char* group_aggregation,
                    size_t num_records,
                    size_t field_offset,
                    bool if_aggr_common
                  ) {
  ...
  switch (op) {
+   case RULE_EQ | RULE_S1_8:
+   case RULE_NE | RULE_S1_8:
+   case RULE_GT | RULE_S1_8:
    ...
+     aggr_function = aggr_static_uint8_t;
+     break;
    ...
  }
...
term->aggr_function = get_aggr_fptr(term->op->field_type);
(*aggr_function)(
                  group->members,
                  group_aggregation,
                  group->num_members,
                  field_offset,
                  TRUE
                );
\end{lstlisting}


The execution engine in F$(v1)$ had a separate filter stage that was executed
in the branch thread. As a result, the branch  was not able to free the
records that failed the filter rule, since they could have passed in some
other branch. The records that failed in all branches were only free'd
\marginpar{early filtering} once all threads joined \texttt{main(\ldots)}
i.e., before calling the \texttt{merger(\ldots)}. The execution engine in
F$(v2)$ pushes the filter stage out of the branch and closer to where the
trace is originally read. This enables the memory allocation of only records
that passed the filter stage thereby reducing the runtime memory footprint of
the engine as shown in listing \ref{lst:fv2-early-filtering}.

\lstset{caption=F$(v2)$: Early Filtering,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-early-filtering,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
struct ft_data *
ft_read (
          struct ft_data* data,
          struct flowquery* fquery
        ) {
  /* process each flow record */
  while ((record = ftio_read(&data->io)) != NULL) {
    /* process each branch */
    for (int i = 0, j; i < fquery->num_branches; i++) {
      /* process each filter clause (clauses are OR'd) */
      for (int k = 0; k < branch->num_filter_clauses; k++) {
        /* process each filter term (terms within a clause are AND'd) */
        for (j = 0; j < fclause->num_terms; j++) {
          /* run the comparator function of the filter rule on the record */
          ...
        }
      }
      /* if rules are satisfied then save this record */
      if (satisfied) {
        /* save the pointer in the filtered recordset */
        ...
        /* write to the output stream, if requested */
        ...
      }
    }
  }
}
\end{lstlisting}




Each branch runs in its own thread. If any of the stages of the branch return
a \texttt{NULL} when returning from their public interface function, there is
no \marginpar{early thread exits} reason to continue the thread. The
subsequent stages of the branch cannot do much with a \texttt{NULL} result.
Therefore, the branch thread returns with a \texttt{EXIT\_FAILURE} if either
stage returns \texttt{NULL}, and with \texttt{EXIT\_SUCCESS} on normal exit as
shown in listing \ref{lst:fv2-early-thread-exits}.

\lstset{caption=F$(v2)$: Early Thread Exits,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-early-thread-exits,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
void * branch_start(void *arg) {
  ...
  if (branch->filter_result == NULL)
    pthread_exit((void*)EXIT_FAILURE);

  branch->grouper_result = grouper(...);
  if (branch->grouper_result == NULL)
    pthread_exit((void*)EXIT_FAILURE);

  branch->gfilter_result = groupfilter(...);
  if (branch->gfilter_result == NULL)
    pthread_exit((void*)EXIT_FAILURE);
  ...

  pthread_exit((void*)EXIT_SUCCESS);
}
\end{lstlisting}




Each stage of the processing pipeline is dependent on the result of the
previous one. As a result, the stages should only proceed and process, when
the previous returned results. Implementing such a response was
straightforward \marginpar{context-aware pipeline stages} for the grouper and
group filter as shown in listing \ref{lst:fv2-context-aware-stages}, the
merger although was a little trickier.  The merger stage proceeds only when
every branch has non-zero filtered groups.  The iterator initializer
\texttt{iter\_init(\ldots)} deallocates and returns \texttt{NULL} if any one
branch has $0$ filtered groups.  Consequently a check is performed in the
merger to make sure \texttt{iter} is \emph{not} \texttt{NULL}.

\lstset{caption=F$(v2)$: Context-Aware Pipeline Stages,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-context-aware-stages,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
/* grouper */
struct grouper_result*
grouper(...) {

  /* go ahead if there is something to group */
  if (fresult->num_filtered_records > 0) {...}
}

/* group filter */
struct groupfilter_result*
groupfilter(...) {

  /* go ahead if there is something to group filter */
  for (int i = 0, j = 0; i < gresult->num_groups; i++) {...}
}

/* merger */
struct merger_result*
merger(...) {

  /* initialize the iterator */
  struct permut_iter* iter = iter_init(num_branches, branchset);
  if (iter == NULL)
    return mresult;
  ...
}
\end{lstlisting}

The results from each stage of the pipeline are echoed to the standard output
just before the engine exits. This leads to an additional loop to echo the
results, however echoes to the standard output are only used for debugging
purposes. \marginpar{inline writes to file} The writes to a file can however
be legitimately requested in a real network analysis task. As a result, it is
essential to avoid additional loops when performing writes to a file. The
execution engine, therefore writes each result record to a file as soon as it
is seen by the pipeline stage. Such a behavior occurs for each pipeline stage
and and for all verbosity levels. The writes to file can be requested using
\texttt{--dirpath} switch in combination with \texttt{--verbose}. A sample
code from the group filter stage is shown in listing
\ref{lst:fv2-inline-writes-file}.

\lstset{caption=F$(v2)$: Inline Writes to File,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-inline-writes-file,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
struct groupfilter_result* groupfilter( ... ) {

  /* initialize an output stream if file write is requested */
  ...
  /* iterate over each group */
  for (int i = 0, j = 0; i < gresult->num_groups; i++) {
    /* process each group filter clause (clauses are OR'd) */
    for (int k = 0; k < num_groupfilter_clauses; k++) {
      /* process each group filter term (terms within a clause are AND'd) */
      for (j = 0; j < gfclause->num_terms; j++) {

        /* run the comparator function of the filter term on the record */
        ...
      }
    }

    /* if rules are satisfied then save this record */
    if (satisfied) {
      /* write the record to the output stream */
      ...
    }
  }
}
\end{lstlisting}


A rundown of the runtime complexity of each stage of the processing pipeline
is shown in table \ref{tab:fv2-pipeline-complexity}. In the table, $n$ is the
total number of flow records  \marginpar{runtime complexity} in the trace,
while $k$ is the number of unique flow records that passed the filter stage,
and $p$ is the number of grouping terms. The number of branches (or threads)
spawned by the execution engine is $m$. It is clear that the merger is
currently the bottleneck of the pipeline and needs further optimizations.

\begin{table}[h!]
	\begin{center}
		\begin{tabular}{|c|c|}
		\hline
		Pipeline Stage & Runtime Complexity \\
		\hline
		\hline
		Filter & $O(n)$ \\
		\hline
		Grouper & $O(p*n*lg(n)) + O(n) + O(n*lg(k))$ \\
		\hline
		Group Aggregation & $O(n)$ \\
		\hline
		Group Filter & $O(n)$ \\
		\hline
		Merger & $O(n^m)$ \\
		\hline
		Ungrouper & $O(n) \\
		\hline
		\end{tabular}
\caption{F$(v2)$: Pipeline Runtime Complexity}
\label{tab:fv2-pipeline-complexity}
	\end{center}
\end{table}
