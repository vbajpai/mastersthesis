\lstset{caption=Group Filter Query Example,
				tabsize=2, language=bash, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:gfilter-example,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
grouper g {
  module g1 {
    srcip = srcip
    dstip = dstip
  }
  aggregate srcip, dstip, sum(packets) as pkts
}

groupfilter gf {
  pkts > 200
}
\end{lstlisting}

A simple query to filter the groups with $sum(pkts) > 200$ is shown in listing
\ref{lst:gfilter-example}. The \texttt{struct} rule holds information about
the flow record offset, the value \marginpar{group filter implementation}
being compared to and the operator which maps to a unique \texttt{enum} value.
This enum value is later used to map the operation to a specific group-filter
function using a \texttt{switch} case case as shown in listing
\ref{lst:fv2-gfilter-implementation}. The group-filter functions are
auto-generated using a python script \texttt{scripts/generate-functions.py}.

\lstset{caption=F$(v2)$: Group Filter Implementation,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-gfilter-implementation,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
struct gfilter_rule gfilter_branch2[1] = {
  {trace_data->offsets.dPkts, 200, 0, RULE_GT, NULL}
};
...

/* for loop for the group-filter */
  for (int j = 0; j < binfos[i].num_gfilter_rules; j++) {
    switch (binfos[i].gfilter_rules[j].op) {
      ...
      case RULE_GT:
        binfos[i].gfilter_rules[j].func = gfilter_gt;
        break;
      ...
    }
  }
\end{lstlisting}

The merger is used to relate the groups from different branches according to a
criterean. A query to merge groups of flow records creating a session between
two endpoints is shown in listing \ref{lst:merger-example}. Similar to the
group filter, a unique \marginpar{merger implementation} \texttt{enum} value
is used to map the operator to a specific specific merger function using a
\texttt{switch} case as shown in listing \ref{lst:fv2-merger-implementation}.
The merger functions are again auto-generated using
\texttt{scipts/generate-functions.py}.

\lstset{caption=Merger Query Example,
				tabsize=2, language=bash, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:merger-example,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
merger m {
  module m1 {
    branches A, B
    A.srcip = B.dstip
    A.dstip = B.srcip
  }
}
\end{lstlisting}

\lstset{caption=F$(v2)$: Merger Implementation,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-merger-implementation,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
struct merger_rule mfilter[2] = {
  {&binfos[0], trace_data->offsets.srcaddr,
   &binfos[1], trace_data->offsets.dstaddr,
   RULE_EQ | RULE_S1_32 | RULE_S2_32, 0, NULL},

  {&binfos[0], trace_data->offsets.dstaddr,
   &binfos[1], trace_data->offsets.srcaddr,
   RULE_EQ | RULE_S1_32 | RULE_S2_32, 0, NULL},
};
...

/* for loop for the merger */
for (int j = 0; j < fquery->num_merger_rules; j++) {
  switch (fquery->mrules[j].op) {
    ...
    case RULE_EQ | RULE_S1_32 | RULE_S2_32:
      fquery->mrules[j].func = merger_eq_uint32_t_uint32_t;
      break;
    ...
  }
}
\end{lstlisting}

The ungrouper implementation is straightforward. Given the group tuples, the
ungrouper \marginpar{ungrouper implementation} returns a set of stream of
flow records. The matched group tuples are generated by the merger. The
ungrouper returns as many streams as there are number of matched group tuples.
An example output is shown in listing \ref{lst:fv2-ungrouper-echo}.

\lstset{caption=F$(v2)$: Ungrouper Result Echo,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-ungrouper-echo,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
$ bin/engine tracefile queryfile

No. of Streams: 2
-----------------

No. of Records in Stream (1): 24

... Sif   SrcIPaddress    SrcP  DIf   DstIPaddress    DstP  ...

... 0     192.168.0.135   56225 0     216.46.94.66    80    ...
... 0     216.46.94.66    80    0     192.168.0.135   56228 ...
\end{lstlisting}



The public interface function \texttt{grouper(\ldots)} call was plagued with
hardcoded \texttt{uint32\_t} type assumptions on the field offset. These field
offsets \marginpar{flexible grouper with no type assumptions} are used to
make grouper rule comparisons. The function now internally calls
\texttt{get\_gtype(\ldots)} to fall through a switch case to determine the
type of the field offset at runtime as shown in listing
\ref{lst:fv2-flexible-grouper}.

\lstset{caption=F$(v2)$: Flexible Grouper,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-flexible-grouper,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
struct grouper_type* get_gtype(uint64_t op) {
  ...
  switch (op) {
    case RULE_S2_8:
      gtype->qsort_comp = comp_uint8_t;
      gtype->bsearch = bsearch_uint8_t;
      gtype->alloc_uniqresult = alloc_uniqresult_uint8_t;
      gtype->get_uniq_record = get_uniq_record_uint8_t;
      gtype->dealloc_uniqresult = dealloc_uniqresult_uint8_t;
      break;
    case RULE_S2_16: ...
    case RULE_S2_32: ...
    case RULE_S2_64: ...
  }
  return gtype;
}
\end{lstlisting}



The group aggregation functions were hardcoded in \texttt{group\_aggr} struct.
The functions \marginpar{flexible group aggregations} are now replaced with
rules that map to a specific aggregation function. The mapping of the rule to
the function is done using a \texttt{switch} case as shown in listing
\ref{lst:fv2-flexible-aggr}.  The aggregation functions are auto-generated
using \texttt{scripts/generate-functions.py}.

\lstset{caption=F$(v2)$: Flexible Group Aggregations,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-flexible-aggr,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
struct grouper_aggr group_aggr_branch1[4] = {

-    { 0, trace_data->offsets.srcaddr, aggr_static_uint32_t },
-    { 0, trace_data->offsets.dPkts, aggr_sum_uint32_t },
+    { 0, trace_data->offsets.srcaddr, RULE_STATIC | RULE_S1_32, NULL },
+    { 0, trace_data->offsets.dPkts, RULE_SUM | RULE_S1_32, NULL },
   };
...

/* for loop for the group-aggregation */
for (int j = 0; j < binfos[i].num_aggr; j++) {
  switch (binfos[i].aggr[j].op) {
    ...
    case RULE_SUM | RULE_S1_32:
      binfos[i].aggr[j].func = aggr_sum_uint32_t;
      break;
      ...
  }
}
\end{lstlisting}

The aggregation function also needs to know the type of the offsets used
previously in the filter and grouper rules to be able to fill in common fields
in its cooked netflow $v5$ group aggregation record. As a result
\marginpar{flexible group aggregation redundancy checks} a
\texttt{get\_aggr\_fptr(\ldots)} function was defined that accepts those
previous rules to fall through a switch to return a function pointer to an
aggregation function of the correct type as shown in listing
\ref{lst:fv2-getaggrfptr}. This aggregation function is then later used to
fill in the common fields. A similar call is made for the grouper rules as
well.

\lstset{caption=F$(v2)$: Flexible Group Filters,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-getaggrfptr,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
struct aggr*
(*get_aggr_fptr(
                 bool ifgrouper,
                 uint64_t op
               )) (
                    char** records,
                    char* group_aggregation,
                    size_t num_records,
                    size_t field_offset,
                    bool if_aggr_common
                  ) {
  ...
  switch (op) {
+   case RULE_EQ | RULE_S1_8:
+   case RULE_NE | RULE_S1_8:
+   case RULE_GT | RULE_S1_8:
    ...
+     aggr_function = aggr_static_uint8_t;
+     break;
    ...
  }
...
aggr_function = get_aggr_fptr(binfo->filter_rules[i].op);
(*aggr_function)(
                  group->members,
                  group_aggregation,
                  group->num_members,
                  field_offset,
                  TRUE
                );
\end{lstlisting}


The group filter struct \texttt{gfilter\_rule} now accepts a \texttt{uint\_X}
enum when mapping functions. The additional enum is used to map to a function
that \marginpar{flexible group filters} knows the type of the offset at
runtime. The additional switch cases and comparison functions are
automatically generated using \texttt{scripts/generate-functions.py}.

\lstset{caption=F$(v2)$: Flexible Group Filters,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-flexible-gfilters,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
  struct gfilter_rule gfilter_branch1[1] = {
-   {trace_data->offsets.dPkts, 200, 0, RULE_GT, NULL}
+   {trace_data->offsets.dPkts, 200, 0, RULE_GT | RULE_S1_32, NULL}
  };

  switch (binfos[i].gfilter_rules[j].op) {
-   case RULE_EQ:
-     binfos[i].gfilter_rules[j].func = gfilter_eq;
+   case RULE_EQ | RULE_S1_32:
+     binfos[i].gfilter_rules[j].func = gfilter_eq_uint32_t;
+   break;
    ...
  }
\end{lstlisting}





Each branch of the pipeline is executed by a separate thread. Since the
branches do \emph{not} have a copy of the trace but point to the original
records, they \emph{cannot} free the records that failed the filter rule,
since they can pass in some other branch. As a consequence, the records that
failed in all branches can only be free'd once all threads join
\texttt{main(\ldots)} ie. before calling the \texttt{merger(\ldots)}. The
n\"aive approach to \marginpar{greedily deallocating non-filtered records}
linearly search non-filtered records by falling through filtered recordset of
each branch is costly and runs in worst case $O(nkm)$ time where $n$ is the
number of records in the trace, $k$ is the number of branches, and $m$ is the
number of filtered records in each branch. Instead, it is better to trade
space for lower runtime complexity. Listing \ref{lst:fv2-greedy-dealloc} shows
how the trace structure is extended to allow a flag that stores
meta-information about the record. The non-filtered records can now be free'd
in worst case $O(n)$ time.

\lstset{caption=F$(v2)$: Greedy Deallocation of Non-Filtered Records
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-greedy-dealloc,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
    struct ft_data {
-     char**                          records;
+     struct record**                 recordset;
+     int                             num_records;
    };

+   struct record {
+     char*                           record;
+     bool                            if_filtered;
+   };
...
+   for (int i = 0; i < param_data->trace->num_records; i++) {
+     struct record* recordinfo = param_data->trace->recordset[i];
+     if (recordinfo->if_filtered == false)
+       free(recordinfo->record); recordinfo->record = NULL;
    }
\end{lstlisting}




There are dedicated comparator functions for each \texttt{uintX\_t} type of
the field offset. Up until now, the choice for the function was made using a
single function, \texttt{assign\_fptr(\ldots)}, which was called before the
start of the pipeline to ensure all function pointers point to the right
functions for each stage as shown in listing \ref{lst:fv1-assign-fptr}.


\lstset{caption=F$(v1)$: Early Comparator Assignments,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv1-assign-fptr,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
assign_fptr(struct flowquery *fquery) {
  for (int i = 0; i < fquery->num_branches; i++) {
    /* for loop for the filter */
    for (int j = 0; j < branch->num_filter_rules; j++) {...}
    /* for loop for the grouper */
    for (int j = 0; j < branch->num_grouper_rules; j++) {...}
    /* for loop for the group-aggregation */
    for (int j = 0; j < branch->num_aggr_rules; j++) {...}
    /* for loop for the group-filter */
    for (int j = 0; j < branch->num_gfilter_rules; j++) {...}
  }
}
\end{lstlisting}

This function is computationally expensive, since it falls through a
\emph{huge} \texttt{switch} statement to determine the function of right type.
It is not guaranteed that given the type of the query and trace, the program
will eventually go through each stage of the pipeline. It is also possible
\marginpar{lazy comparator assignments} that the program exits before, because
there is nothing more for the next stage to compute. The function pointers
should therefore be set as late as possible as shown in listing
\ref{lst:fv2-lazy-rule-assign}. Each of these functions are called from their
respective stages just before the comparison.  As a result, we save the
computation time wasted in setting the function pointer for stage $X$ if $X$
is never executed.

\lstset{caption=F$(v2)$: Lazy Comparator Assignments,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-lazy-rule-assign,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
assign_filter_func(struct filter_rule* const frule) {...}
assign_grouper_func(struct grouper_rule* const grule) {...}
assign_aggr_func(struct aggr_rule* const arule) {...}
assign_gfilter_func(struct gfilter_rule* const gfrule) {...}
assign_merger_func(struct merger_rule* const mrule) {...}
\end{lstlisting}


Each branch runs in its own thread. If any of the stages of the branch return
a \texttt{NULL} when returning from their public interface function, there is
no \marginpar{early thread exits} reason to continue the thread. The
subsequent stages of the branch cannot do much with a \texttt{NULL} result.
Therefore, the branch thread returns with a \texttt{EXIT\_FAILURE} if either
stage returns \texttt{NULL}, and with \texttt{EXIT\_SUCCESS} on normal exit as
shown in listing \ref{lst:fv2-early-thread-exits}.

\lstset{caption=F$(v2)$: Early Thread Exits,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-early-thread-exits,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
void *
branch_start(void *arg) {
  ...
  branch->filter_result = filter(...);
  if (branch->filter_result == NULL)
    pthread_exit((void*)EXIT_FAILURE);
  branch->grouper_result = grouper(...);
  if (branch->grouper_result == NULL)
    pthread_exit((void*)EXIT_FAILURE);
  branch->gfilter_result = groupfilter(...);
  if (branch->gfilter_result == NULL)
    pthread_exit((void*)EXIT_FAILURE);
  ...
  pthread_exit((void*)EXIT_SUCCESS);
}
\end{lstlisting}




Each stage of the processing pipeline is dependent on the result of the
previous one. As a result, the stages should only proceed and process, when
the previous returned results. Implementing such a response was
straightforward \marginpar{context-aware pipeline stages} for the grouper and
group filter as shown in listing \ref{lst:fv2-context-aware-stages}, the
merger although was a little trickier.  The merger stage proceeds only when
every branch has non-zero filtered groups.  The iterator initializer
\texttt{iter\_init(\ldots)} deallocates and returns \texttt{NULL} if any one
branch has $0$ filtered groups.  Consequently a check is performed in the
merger to make sure \texttt{iter} is \emph{not} \texttt{NULL}.

\lstset{caption=F$(v2)$: Context-Aware Pipeline Stages,
				tabsize=2, language=C, numbers=left,stepnumber=1,
        basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
        keywordstyle=\color{blue}, frame=shadowbox,
        rulesepcolor=\color{black}, label=lst:fv2-context-aware-stages,
        aboveskip=20pt, captionpos=b}
\begin{lstlisting}
/* grouper */
struct grouper_result*
grouper(...) {

  /* go ahead if there is something to group */
  if (fresult->num_filtered_records > 0) {...}
}

/* group filter */
struct groupfilter_result*
groupfilter(...) {

  /* go ahead if there is something to group filter */
  for (int i = 0, j = 0; i < gresult->num_groups; i++) {...}
}

/* merger */
struct merger_result*
merger(...) {

  /* initialize the iterator */
  struct permut_iter* iter = iter_init(num_branches, branchset);
  if (iter == NULL)
    return mresult;
  ...
}
\end{lstlisting}




A rundown of the runtime complexity of each stage of the processing pipeline
is shown in table \ref{tab:fv2-pipeline-complexity}. In the table, $n$ is the
total number of flow records  \marginpar{runtime complexity} in the trace,
while $k$ is the number of unique flow records. The number of branches (or
threads) spawned by the execution engine is $m$. It is clear that the merger
is currently the bottleneck of the pipeline and needs further optimizations.

\begin{table}[h!]
	\begin{center}
		\begin{tabular}{|c|c|}
		\hline
		Pipeline Stage & Runtime Complexity \\
		\hline
		\hline
		Filter (worst case) & $O(n)$ \\
		\hline
		Grouper (average case) & $O(n*lg(n)) + O(n) + O(n*lg(k))$ \\
		\hline
		Group Aggregation (worst case) & $O(n)$ \\
		\hline
		Merger (worst case) & $O(n^m)$ \\
		\hline
		Ungrouper (worst case) & $O(n) \\
		\hline
		\end{tabular}
\caption{F$(v2)$: Pipeline Runtime Complexity}
\label{tab:fv2-pipeline-complexity}
	\end{center}
\end{table}
