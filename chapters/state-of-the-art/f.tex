%**************************************
\chapter{F}\label{ch:f}
%**************************************

In lieu of the significant leaps made by Flowy $2.0$ in making the initial prototype usable, additional efforts were made by the same author to work upon the enlisted areas of improvements mentioned in $\ref{sec:flowy2-future}$. To mark this evolution of initial prototype to the current bleeding edge state, it was decided to rename the implementation to F \cite{jschauer:2012} with an exhaustive performance evaluation against the state-of-the-art flow processing tools \cite{sromig:2000, phaag:2006} that operate on absolute filters.

\section{Rule Interfaces}\label{sec:rule-interfaces}
The design of the rule interfaces for a flow-query was rethought. An object-oriented approach was followed to abstract out details into multiple levels of inheritance. The \texttt{flowquery} struct for instance, is the parent of all the rule interfaces as shown in listing $\ref{lst:flowqueryrule}$.
\lstset{caption=Flow Query Struct \cite{jschauer:2012}, 
				tabsize=2, language=C, numbers=left,stepnumber=1,
				numberstyle=\ttfamily\color{gray}, keywordstyle=\color{blue},
				frame=shadowbox, rulesepcolor=\color{black}, 	
			  label=lst:flowqueryrule, aboveskip=20pt, captionpos=b}
\begin{lstlisting}
struct flowquery {
	size_t num_branches;
	struct branch_info *branches;
	struct merger_rule **mrules;
};
\end{lstlisting}

\texttt{branch\_info} struct defines rules for each branch. It conglomerates filter, grouper and group-filter stages as shown in listing $\ref{lst:branchinforule}$. 
\lstset{caption=Branch Info Struct \cite{jschauer:2012}, 
				tabsize=2, language=C, numbers=left,stepnumber=1,
				numberstyle=\ttfamily\color{gray}, keywordstyle=\color{blue},
				frame=shadowbox, rulesepcolor=\color{black}, 	
			  label=lst:branchinforule, aboveskip=20pt, captionpos=b}
\begin{lstlisting}
struct branch_info {
	int branch_id;
	struct ft_data *data;
	struct filter_rule *filter_rules;
	size_t num_filter_rules;
	struct grouper_rule *group_modules;
	size_t num_group_modules;
	struct grouper_aggr *aggr;
	size_t num_aggr;
	struct gfilter_rule *gfilter_rules;
	size_t num_gfilter_rules;
	struct group **filtered_groups;
	size_t num_filtered_groups;
};
\end{lstlisting}

\begin{center}
\begin{minipage}{.44\textwidth}
	\lstset{caption=Grouper Struct \cite{vperelman:thesis:2010}, 
					tabsize=2, language=C, numbers=left,stepnumber=1,
					basicstyle=\tiny\ttfamily,numberstyle=\ttfamily\color{gray},
					keywordstyle=\color{blue},frame=shadowbox, rulesepcolor=\color{black}, 	
				  label=lst:grouperrule, aboveskip=20pt, captionpos=b}
	\begin{lstlisting}
	struct grouper_rule {
		size_t field_offset1;
		size_t field_offset2;
		uint64_t delta;
		uint16_t op;
		bool (*func)(
		  struct group *group,
		  size_t field_offset1,
		  char *record2,
		  size_t field_offset2,
		  uint64_t delta);
	};
	\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{.44\textwidth}
	\lstset{caption=Group Struct \cite{vperelman:thesis:2010}, 
					tabsize=2, language=C, numbers=left,stepnumber=1,
					basicstyle=\tiny\ttfamily, numberstyle=\ttfamily\color{gray},
					keywordstyle=\color{blue},frame=shadowbox, rulesepcolor=\color{black}, 	
				  label=lst:grouprule, aboveskip=20pt, captionpos=b}
	\begin{lstlisting}
	struct group {
		char        **members;
		size_t      num_members;
		struct aggr *aggr;
		uint32_t    start;
		uint32_t    end;
	};

	struct aggr {
	  size_t   num_values;
	  uint64_t *values;
	};
	\end{lstlisting}
\end{minipage}
\end{center}
The group-filter struct is similar to the filter struct previously shown in listing $\ref{lst:filterrule}$. The grouper struct is shown in listing $\ref{lst:grouperrule}$ and is used to perform relative comparison on the flow-records. It takes in offsets of the fields to be grouped, their lengths and a comparison function. Possible comparison functions are \texttt{eq}, \texttt{ne}, \texttt{lt}, \texttt{gt}, \texttt{le} and \texttt{ge}. The comparison function creates a \texttt{group} instance, a pointer to which is passed to it. The group struct is shown in listing $\ref{lst:grouprule}$ which apart from the information about the members, also points to a grouper aggregation struct that contains meta-information resulting from calling an aggregation function. 
\lstset{caption=Grouper Aggregation Struct \cite{jschauer:2012}, 
				tabsize=2, language=C, numbers=left,stepnumber=1,
				numberstyle=\ttfamily\color{gray}, keywordstyle=\color{blue},
				frame=shadowbox, rulesepcolor=\color{black}, 	
			  label=lst:grouperaggrrule, aboveskip=20pt, captionpos=b}
\begin{lstlisting}
struct grouper_aggr {
	int module;
	size_t field_offset;
	struct aggr (*func)(
	  char **group_records,
	  size_t num_records,
	  size_t field_offset);
};
\end{lstlisting}
The grouper aggregation struct is shown in listing $\ref{lst:grouperaggrrule}$ and consists of the module to aggregate over, the field offset and the aggregation function. Possible aggregation functions are \texttt{static}, \texttt{count}, \texttt{union}, \texttt{min/max}, \texttt{mean/median}, \texttt{stddev}, \texttt{sum/prod}, \texttt{and/or/xor}. The merger stage struct is the same as was previously shown in listing $\ref{lst:mergerrrule}$ and allows relative comparison between groups from different branches. 

The rules are now possible to be written in \ac{CNF}. \ac{CNF} allow the flexibility to define every possible logical expression with the available comparison operations. The comparison (\texttt{>>} and \texttt{<<}) and the \texttt{intersect} aggregation operations still need to be implemented though as was previously mentioned in section $\ref{subsec:additional-functionality}$. 

\section{Flowy $2.0$ Improvements}\label{sec:flowy-2-improvements}
This study focusses on optimizing deep nested loops in each processing stage and improving the overall complexity of the grouper and merger as previous enlisted in sections $\ref{subsec:special-fns}$ and $\ref{subsec:search-trees}$.

\subsection{Efficient Rule Processing}\label{sec:rule-processing}
The comparison operations, previously were required to make costly checks on the length of the field type passed to them, to be able to make appropriate casts. Such checks are now no longer needed. F now allows filtering of records (and groups) via two methods: using specialized comparison functions or using one main fall through \texttt{switch} statement. The implementation defaults to using specialized comparison functions to encourage modularity in source code. 

\lstset{caption=Auto Generated Comparison Functions \cite{jschauer:2012}, 
				tabsize=2, language=C, numbers=left,stepnumber=1,
				numberstyle=\ttfamily\color{gray}, keywordstyle=\color{blue},
				frame=shadowbox, rulesepcolor=\color{black}, 	
			  label=lst:autocompfunc, aboveskip=20pt, captionpos=b}
\begin{lstlisting}
bool filter_eq_uint8_t(...);
bool filter_eq_uint16_t(...);
...
\end{lstlisting}
In the default method, there is a comparison function defined for every possible field length $(33)$ and comparison operations $(19)$. These functions are generated using a \marginpar{using function pointers}Python script \footnote{\texttt{fun\_gen.py}} and are declared/defined in \texttt{auto\_comps.\{h,c\}} as shown in listing $\ref{lst:autocompfunc}$. The rule definitions are now able to make calls using a function name derived from the combination of field length, delta type and operation. This subverts the need to define complex branching statements and reduces complexity. 

\lstset{caption=Auto Generated Switch Statement \cite{jschauer:2012}, 
				tabsize=2, language=C, numbers=left,stepnumber=1,
				numberstyle=\ttfamily\color{gray}, keywordstyle=\color{blue},
				frame=shadowbox, rulesepcolor=\color{black}, 	
			  label=lst:autoswitch, aboveskip=20pt, captionpos=b}
\begin{lstlisting}
switch (group_modules[k].op) {
  case RULE_EQ | RULE_S1_8 | RULE_S2_8 | RULE_ABS:
  case RULE_EQ | RULE_S1_8 | RULE_S2_8 | RULE_REL:
  ...
\end{lstlisting}
In the other method, the logic is executed by comparing the field length and the operation \marginpar{using switch statement} by falling through a huge switch statement. Such a huge switch statement is again generated using the same Python script and is defined in \texttt{auto\_switch.c} as shown in listing $\ref{lst:autoswitch}$.  

\subsection{Divide and Conquer for
Fast Relative Comparisons}\label{sec:binary-search}
The grouper and the merger have always been the performance hit stages of the processing pipeline. In the previous implementation, the grouper had a complexity of $O(n^2)$ whereas the merger had a complexity of $O(n^m)$ where $n$ is the number of groups and $m$ is the number of branches. 

In order to reduce the number of comparisons in these stages, using a binary search after a quick sort on the flow (or group) records was thought out. To achieve this, the array of pointers to flow (or group) records were sorted according to the first grouping (or merging) rule. Such a sorted array of pointers was then \marginpar{using quick sort and binary search} traversed linearly to find unique values and point to them using another array of pointers to records. This helped the grouper (and the merger) perform binary searches to find records that would group together, by using the knowledge of records that satisfied the first rule. This eventually reduced the complexity to $O(n*k)$ for the grouper, and $O(n^{m-1} *k)$ for the merger, where $k << n$. 

However, it still looks like having an actual search tree would benefit the grouper and merger, whereby one of the fields will be traversed sequentially in $O(n)$ \marginpar{using search trees} time and for each field, the comparison will be performed by search tree lookups in $O(log(n))$ time bringing down the complexity to $O(nlog(n))$ and is a future action item.


\section{Benchmarks}\label{sec:f-benchmarks}