The semantics and implementation of \ac{NFQL} has undergone significant
changes in the last few years. This section is dedicated to perform an
inside-out study of the language and its prototypes, examining all their major
(and minor) changes to allow us to better make a pragmatic stand towards its
overall improvement. The organization of the section is described below.

\vspace{50pt}

In chapter $\ref{ch:flowy-design}$ we look into the structure of \ac{NFQL} by
discussing each stage of the processing pipeline with their implementation
details. The basic structures of the Flowy python framework are also discussed
to understand its current limitations.

In chapter $\ref{ch:flowy-mapreduce}$ we investigate the possibility of making
\ac{NFQL} map/reduce aware. The chapter starts off with a discussion of
current map/reduce frameworks and looks into the ways to help parallelize the
Flowy.

In chapter $\ref{ch:flowy-2}$ we look into the first attempt to make \ac{NFQL}
implementation comparable with the state-of-the-art flow-analysis tools. After
drilling down the performance hit sections of the python code, we witness how
getting away with \texttt{pytables} and rethinking the rewrite of processing
pipeline in C may help make it practically usable.

We conclude this discussion in chapter $\ref{ch:flowy-applications}$ by
introducing a number of real-life application scenarios where \ac{NFQL} has
proved useful. We also look into a few current bleeding edge research
projects where we believe \ac{NFQL} could play a vital role in the near
future.
