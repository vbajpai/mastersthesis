%*******************************************************
% Abstract
%*******************************************************
%\renewcommand{\abstractname}{Abstract}
\pdfbookmark[1]{Abstract}{Abstract}
\begingroup
\let\clearpage\relax
\let\cleardoublepage\relax
\let\cleardoublepage\relax
\chapter*{Abstract}

Cisco's NetFlow protocol \cite{rfc3954} and \ac{IETF}'s \ac{IPFIX}
\cite{rfc5101} open standard have contributed heavily in pushing \ac{IP} flow
export as the de-facto technique for sending traffic patterns. These patterns
have the potential to be used for billing and mediation, bandwidth
provisioning, detecting malicious attacks, network performance evaluation and
overall improvement. \\

However, making sense of these patterns calls for sophisticated flow analysis
tools that can mine them for such a usage. Unfortunately current tools fail to
deliver owing to their poor language design and simplistic filtering methods.
Our research group, by going clean slate has developed the \ac{NFQL}
\cite{vmarinov:thesis:2009} that can cap flow-exports to full potential. It can
process flow records, aggregate them into groups, apply absolute (or relative)
filters and invoke Allen interval algebra rules \cite{fallen:1983} on them. \\

Flowy \cite{kkanev:thesis:2009} is the prototype implementation of \ac{NFQL},
which has undergone significant changes in the last few years.  The core of
this Python implementation is now being rewritten in C to make it comparable
to the contemporary flow processing tools. The first major release in this
effort, $F(v1)$ \cite{jschauer:thesis:2011} can now read the flow-records in
memory and apply absolute filters. The absolute filters, however are only one
amongst the five stages of the complete \ac{NFQL} processing pipeline. The
rest of the stages either have a broken implementation or are completely
non-existent. The flowquery used by the execution engine to mine the traces
is also hardcoded in pipeline structs. \\

This thesis extends $F(v1)$ to provide a complete usable implementation of
\ac{NFQL} with \emph{functional} pipeline stages. The engine is \emph{robust}
to work well with variety of \ac{NFQL} queries that are now read and parsed at
runtime using the \texttt{JSON} intermediate format. The filter and grouper
implementations have also been reimagined to bring forth an orders of
magnitude performance speedup. $F(v2)$ is \emph{portable} with automated
builds using \texttt{cmake} and is \emph{verifiable} using a regression
test-suite framework. An automated benchmarking suite enables the conducted
performance evaluations to be repeatable. The conducted performance
evaluations reveal that $F(v2)$ can now process flow traces with millions of
records in matter of minutes, which used to take days in F$(v1)$. Such a
performance boost makes $F(v2)$ comparable to contemporary flow-processing
tools.

%However, this has disconnected the flow-query parser present
%in the former implementation. The two implementations have now branched off so
%much that both currently live in their own parallel universe. This thesis
%takes up the challenge to glue the better parts of both of these
%implementations together to create a complete package that has the full-blown
%functionality and exploits the best of both worlds. In the process, it is also
%planned to bring the implementation up to speed with bleeding edge \ac{IPFIX}
%support, parallelize it by making it MapReduce \cite{jdean:2004} aware and
%recover it from limitations learnt from the wealth of experience gained after
%managing the two branches for the last few years.

\endgroup
\vfill
